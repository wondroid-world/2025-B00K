## UI 유연성

- 사용자나 장치가 요구하는 것에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력

액티비티는 UI 유연성을 제공하도록 설계되어 있지 않다.

- 액티비티의 뷰들은 런타임 시에 변경된다.
- 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다.
- 사용하는 특정 화면과 강하게 결합되어 있다.

→ 하나 이상의 프래그먼트를 사용하면 앱 UI를 유연하게 사용할 수 있다.

## 프래그먼트

- 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체
- 액티비티의 작업 == 화면 전체 또는 일부분의 UI 관리
- 프래그먼트는 화면에 보이는 뷰를 자체적으로 가질 수 없다.
- 액티비티의 뷰 계층에 추가될 때만 화면에 자신의 뷰가 보인다.
- UI를 생성하고 관리하며 모델 객체들과 상호 작용하는 일을 한다.

## UI 프래그먼트

- UI를 관리하는 프래그먼트
- 레이아웃 파일로부터 인플레이트(inflate)되는 자신의 뷰를 하나 가진다.
- 프래그먼트의 뷰는 사용자가 보면서 상호작용하기를 원하는 UI 요소들을 포함한다.
- 앱의 UI를 조립 가능한 요소로 분리할 수 있다.
- 탭 인터페이스를 비롯한 여러 가지를 쉽게 만들 수 있다.
- ex) 네비게이션 컨트롤러

## 액티비티 뷰

- 자신의 UI를 갖는 대신 프래그먼트를 넣을 컨테이너를 가진다.
- 컨테이너는 인플레이트된 프래그먼트의 뷰를 추가할 수 있다.
- 액티비티는 다수의 컨테이너도 가질 수 있다.
- 액티비티 생애 동안 함께 존재하므로 안드로이드의 기본 원칙에도 위배되지 않는다.

## Fragment (UI 프래그먼트)

Fragment의 인스턴스 → MainActivity가 호스팅

## UI 프래그먼트 생성하기

1. 레이아웃 파일에 위젯들을 정의해 UI를 구성한다.
2. 클래스를 생성하고 정의된 레이아웃을 이 클래스의 뷰로 설정한다.
3. 레이아웃으로부터 인플레이트된 위젯들을 코드에 연결한다.

## UI 프래그먼트의 호스팅

- 액티비티의 레이아웃에 프래그먼트의 뷰를 배치할 곳을 정의해야 한다.
- 프래그먼트 인스턴스의 생명주기를 관리해야 한다.

## FragmentManager

- 프래그먼트 리스트와 프래그먼트 트랜잭션의 백 스택을 처리한다.
- 프래그먼트의 뷰를 액티비티의 뷰 계층에 추가하고 프래그먼트의 생명주기를 주도하는 책임을 가진다.
- 프래그먼트 트랜잭션이 다수의 오퍼레이션을 포함한다면 해당 트랜잭션이 백 스택에서 제거될 때 이 오퍼레이션들이 역으로 실행된다. → 다수의 프래그먼트 오퍼레이션들을 하나의 트랜잭션으로 묶으면 UI 상태를 더욱 잘 제어할 수 있다.

## 프래그먼트 트랜잭션

- Jetpack 라이브러리와 AppCompatActivity 클래스를 사용하고 있으면 supportFragmentManager 속성을 사용해서 액티비티의 프래그먼트 매니저를 참조할 수 있다.
- 프래그먼트 리스트에 프래그먼트들을 추가, 삭제, 첨부, 분리, 변경하는 데 사용한다.
- 프래그먼트 트랜잭션을 사용하면 여러 개의 오퍼레이션을 묶어서 수행할 수 있다. ex) 여러 개의 프래그먼트를 동시에 서로 다른 컨테이너에 추가하는 경우
- 프래그먼트로 런타임 시에 화면 구성 또는 변경하는 방법의 핵심

## 컨테이너 뷰 ID의 목적

1. 액티비티 뷰의 어느 위치에 프래그먼트 뷰가 나타나야 하는지를 FragmentManager에 알려준다.
2. FragmentManager의 리스트에서 프래그먼트를 고유하게 식별하는 데 사용된다.

프래그먼트는 여러 이유로 액티비티가 소멸되었다가 다시 생성될 때를 대비해서 리스트에 보존한다. → 장치가 회전되거나 소멸되었다가 안드로이드 운영체제의 메모리 회수로 액티비티가 소멸되었다가 다시 생성되면 액티비티가 소멸될 때 해당 액티비티의 FragmentMAnager 인스턴스가 해당 액티비티의 프래그먼트 리스트를 보존한다. 해당 액티비티가 다시 생성되면 새로운 FragmentManager 인스턴스가 그 리스트를 가져와서 리스트에 있는 프래그먼트를 다시 생성해 이전 상태로 복원한다.

## Fragment의 생명주기

- 생명주기 함수는 public이어야 한다.
- 프래그먼트를 호스팅하는 어떤 액티비티에서도 자동 호출될 것이기 때문
- 액티비티와 유사하게 자신의 상태 데이터를 저장하거나 가져오는 Bundle 객체를 갖는다.
- 액티비티와 프래그먼트의 생명주기는 대응된다. → 프래그먼트는 액티비티를 대신해 작동하므로 프래그먼트의 상태는 액티비티의 상태를 반영해야 한다.
- 프래그먼트 생명주기와 액티비티 생명주기가 다른 점 → 프래그먼트 생명주기 함수는 안드로이드 운영체제가 아닌 호스팅 액티비티의 FragmentManager가 호출한다.

## onCreate()

- onClickListener사용자와 상호 작용할 때만 반응하므로 뷰에 데이터를 설정하는 것에 영향을 받지 않아서 onCreate에서 할 수 있었다.

## onCreateView()

- 프래그먼트 뷰를 인플레이트한다.
- 인플레이트된 View를 호스팅 액티비티에 반환해야 한다.
- Bundle의 저장된 상태 데이터를 onCreateView에서 재생성하는 데 사용된다.
- LayoutInflater.inflate(…)를 호출함으로써 프래그먼트의 뷰를 명시적으로 인플레이트한다.
- LayoutInflater.inflate(R.layout.fragment, container, false)

→ 첫 번째 인자는 레이아웃 리소스 ID를 인자로 전달한다.

→ 두 번째 인자는 위젯들을 올바르게 구성하는 데 필요한 뷰의 부모이다.

→ 세 번째 인자는인플레이트된 뷰를 이 뷰의 부모에게 즉시 추가할 것인지를 LayoutInflater에게 즉시 알려준다.

- 뷰 아이템의 참조를 얻는다 (ex. TextView)

## onStart()

- 장치 회전 등으로 인해 뷰 상태가 복원되면서 데이터가 설정될 때도 작동되는 리스너가 있으면 리스너를 onStart()에서 설정해야 한다.
