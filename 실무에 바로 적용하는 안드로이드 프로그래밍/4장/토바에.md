# UI 상태 유지하기
## ViewModel 의존성 추가하기
ViewModel을 프로젝트에 추가하기 위해 의존성에 lifecycle-extensions 라이브러리를 추가한다.

app/build.gradle에 lifecycle-extensions 의존성 추가하기
  ```
  dependencies {
    implementation 'androidx.lifecycle:lifecycle-extenstions:2.2.0'
  }
  ```

## ViewModel 추가하기
ViewModel은 특정 액티비티 화면과 연동된다.
해당 화면에 보여줄 데이터를 형식화하는 로직을 두기 좋다.
-> ViewModel이 하는 일: 모델 데이터를 화면에 보여주는 기능
ViewModel을 사용하면 화면에서 필요한 모든 데이터를 한곳에서 종합하고 데이터를 형식화할 수 있다.

ViewModel은 androidx.lifecycle 패키지의 일부이다.

androidx.lifecycle이란?
생명주기를 인식하는 컴포넌트를 비롯해서 생명주기 관련 API를 제공한다.
생명주기를 인식하는 컴포넌트 -> 액티비티오 ㅏ같은 다른 컴포넌트의 생명주기를 관찰하고 상태를 고려해 작동한다.

생명주기 인식 컴포넌트
- ViewModel
- LiveData
-> 생명주기 인식 컴포넌트를 생성할 수도 있다.

ViewModel의 init {}
- 뷰 모델의 인스턴스가 생성될 때 자동으로 실행된다.

ViewModel의 onCleared()
- 뷰 모델의 인스턴스가 소멸되기 전에 호출된다.

ViewModel의 인스턴스 사용하기
```
val provider: ViewModelProvider = ViewModelProvider(this)
val quizViewModel: provider.get(QuizViewModel::class.java)
```
ViewModelProvider(this)를 호출하면 현재 액티비티와 연관된 ViewModelProvider 인스턴스를 생성하고 반환한다.
provider.get(QuizViewModel::class.java)를 호출하면 QuizViewModel의 인스턴스를 반환한다.


ViewModelProvider
- ViewModel의 레지스트리처럼 작동한다.
- 액티비티 인스턴스가 처음으로 QuizViewModel을 요청하면 ViewModelProvider가 새로운 QuizViewModel 인스턴스를 생성하고 반환한다.
- 장치 구성이 변경되어 새로 생성된 액티비티 인스턴스가 QuizViewModel을 요청하면 새로운 인스턴스가 생성되지 않고 최초 생성되었던 인스턴스가 반환된다.
- 액티비티 인스턴스가 종료되어 소멸될 때는 QuizViewModel의 인스턴스도 같이 메모리에서 제거된다.
-> 인스턴스가 종료되어 소멸될 때: 사용자가 백 버튼을 눌렀을 때.

## ViewModel 생명주기와 ViewModelProvider
액티비티의 isFinishing 속성
- true: 사용자가 액티비티를 끝냈을 때 (백 버튼을 눌렀을 때, 오버뷰 화면에서 해당 앱 카드를 없앴을 때)
- false: 장치 회전의 구성 변경으로 인해 시스템이 액티비티의 인스턴스를 소멸시킬 때
- false일 때, 사용자는 UI 상태가 보존되기를 기대한다.

ViewModel의 생명주기는 액티비티가 종료될 때만 소멸되기 때문에 사용자의 기대를 잘 반영할 수 있다.

액티비티는 ViewModel을 참조하지만, ViewModel은 액티비티를 참조하지 않는다.

ViewModel은 액티비티나 다른 뷰의 참조를 가지면 안 된다.
-> 메모리 릭이 생길 수 있기 때문에

소멸되어야 하는 객체의 참조를 다른 객체가 가지면 메모리 릭이 생길 수 있다.
-> 참조되어 있는 객체를 가비지 컬렉터가 제거할 수 없게 된다.

ViewModel 인스턴스가 액티비티 인스턴스에 강한 참조를 가지면 생기는 문제
1. 액티비티 인스턴스가 메모리에서 제거되지 않아서 이 인스턴스가 사용하는 메모리가 유실된다.
2. ViewModel 인스턴스가 현재 사용되지 않는 과거 액티비티의 참조를 갖게 되어 ViewModel 인스턴스가 과거 액티비티의 뷰를 변경하려고 하면 IllegalStateException이 발생한다.

ViewModel은 자신과 연관된 화면에서 필요한 모든 데이터를 저장하고 형식화한다.
-> 프레젠테이션 로직 코드를 액티비티와 분리할 수 있어서 액티비티를 좀 더 간단하게 유지할 수 있다.

액티비티는 가능한 간단하게 유지하는 것이 좋다.
-> 액티비티에 추가되는 모든 코드는 뜻하지 않게 액티비티 생명주기의 영향을 받을 수 있기 때문
-> 화면에 나타나는 것만 처리하고 보여줄 데이터를 결정하는 내부 로직은 신경쓰지 않아도 된다.

지연 초기화 by lazy
- var이 아닌 val 속성으로 선언할 수 있어서 좋다. 액티비티 인스턴스가 생성될 때 ViewModel 인스턴스 참조를 ViewModel에 한번만 저장하기 때문
- 최초로 ViewModel이 사용될 때까지 초기화를 늦춰줄 수 있다.

## 프로세스 종료 시에 데이터 보존하기
안드로이드 운영체제가 액티비티 인스턴스를 소멸시키는 때는 장치의 구성 변경이 생길 때만은 아니다.
사용자가 다른 앱으로 이동하거나 안드로이드 운영체제가 메모리를 회수할 때 앱의 프로세스는 안드로이드 운영체제에 의해 소멸된다.
앱의 프로세스가 소멸될 때는 이 프로세스에 저장된 모든 객체들도 같이 소멸된다.

앱은 리눅스 프로세스로 실행된다.
프로세스는 UI 관련 작업을 실행하는 하나의 스레드와 앱의 객체들을 저장하는 메모리를 포함한다.

안드로이드 운영체제가 리소스를 회수할 때는 우선순위가 낮은 프로세스를 먼저 선택하지만, 화면에 보이는 리소스는 회수되지 않는다.
-> 만약 화면에 보이면서 사용자와 상호작용하는 포그라운드 프로세스의 리소스가 회수된다면 장치에 문제가 생긴 것이다.

'중단' 상태의 액티비티는 종료시킬 좋은 대상이 된다.
사용자가 앱을 사용하다가 홈 버튼을 눌러 다른 앱에서 비디오를 보거나 게임을 한다면 앱의 프로세스가 소멸될 수 있다.

안드로이드 운영체제가 앱의 프로세스를 소멸시킬 때는 메모리에 있는 앱의 모든 액티비티들과 ViewModel들이 제거되지만, 액티비티나 ViewModel의 그 어떤 생명주기 콜백 함수도 호출하지 않는다.

액티비티가 소멸될 때 UI 상태 데이터를 보존해 액티비티의 재구성에 사용할 수 있는 방법
-> Saved Instance State에서 데이터를 저장하는 것

액티비티가 '중단' 상태로 바뀔 때 안드로이드 운영체제가 Activity.onSaveInstanceState(Bundle)을 호출한다.

Bundle
- 문자열 키와 이 키의 값을 쌍으로 갖는 구조체
- Bundle 객체에 저장된 뷰들의 상태 데이터를 사용해서 액티비티의 뷰 계층을 다시 생성한다.
- 안드로이드 운영체제에 의해 액티비티의 액티비티 레코드(Activity record)로 저장되기 때문

액티비티가 보존 상태면 액티비티 인스턴스는 존재하지 않지만, 액티비티 레코드 객체는 안드로이드 운영체제에 살아있다.
-> 이를 사용해서 액티비티를 되살릴 수 있다.

액티비티 레코드가 없어질 때
- 액티비티가 종료될 때 (사용자가 종료할 때?)
- 장치가 다시 부팅될 때

## ViewModel vs SIS
SIS로 충분한데, ViewModel을 사용하는 이유는 뭘까?
- 대부분의 앱은 하드코딩된 데이터에 의존하지 않고 데이터베이스, 인터넷 등으로부터 동적인 데이터를 가져온다.
- 비동기적이면서 느릴 수 있고, 장치의 배터리나 네트워크 리소스를 많이 사용한다.
- 액티비티 생명주기와 결속해서 처리하면 오류가 많이 생길 수 있다.

ViewModel의 진가는 액티비티의 동적 데이터를 가져올 때 발휘된다
- ViewModel은 장치의 구성 변경이 생겨도 다운로드 작업을 계속할 수 있게 해준다.
- 하지만 프로세스가 종료되면 ViewModel이 처리하지 못한다. 자신이 가진 모든 것이 프로세스와 함게 메모리에서 제거되기 때문
-> SIS는 직렬화되어 디스크에 저장되므로 크거나 복잡한 객체를 저장할 수 없다는 제약을 가진다.

SIS를 사용해야 할 때
- UI 상태를 다시 생성하기 위해 필요한 소량의 정보를 저장할 때

ViewModel을 사용할 때
- 장치의 구성 변경이 생겨서 UI에 넣는 데 필요한 많은 데이터에 빠르고 쉽게 접근하고자 메모리에 캐싱할 때

Shared Preference, 로컬 데이터베이스, 원격 서버에서 데이터를 가져오는 것
- 액티비티의 상태와 무관하게 앱이 장치에 설치되어 있는 동안 계속 남아 있어야 할 데이터를 저장해야 할 때






